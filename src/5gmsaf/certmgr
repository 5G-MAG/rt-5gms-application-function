#!/bin/bash
#
# 5G-MAG Reference Tools: Certificate Management script
# ======================================================
#
# For full license terms please see the LICENSE file distributed with this
# program. If this file is missing then the license can be retrieved from
# https://drive.google.com/file/d/1cinCiA778IErENZ3JN52VFW-1ffHpx7Z/view
#
# This script will use wget and git to download the openapi-generator-cli tool
# and a specified branch of the 5G APIs. It will then create a set of bindings
# in a specified output language.
#

# Save location of this script and the name it was called by
scriptname=`basename "$0"`
scriptdir=`dirname "$0"`
scriptdir=`cd "$scriptdir"; pwd`

# Variables
default_cert_op=
cert_operation=
cert_store="@path@"
common_name=
server_certificate_resource_id=
cert_status=
cert_subject=

# Parse command line arguments
ARGS=`getopt -n "$scriptname" -o 'c:h' -l 'cert-operation:,help' -s sh -- "$@"`

print_syntax() {
    echo "Syntax: $scriptname [-h] -c <certificate operation>"
}

if [ $? -ne 0 ]; then
    print_syntax >&2
    exit 1
fi

print_help() {
    cat <<EOF
5G-MAG Reference Tools - Certificate Management tool

EOF
    print_syntax
    cat <<EOF

Options:
  -h            --help                         Show this help message and exit.
  -c CERTOPS    --cert-operation CERTOPS       Certificate Operation (One of: newcsr, newcert, list and their parameteres).
EOF
}

eval set -- "$ARGS"
unset ARGS

CERTOPS="$default_cert_op"

while true; do
    case "$1" in
    -c|--cert-operation)
	CERTOPS="$2"
	shift 2
	continue
	;;
    -h|--help)
	print_help
	exit 0
	;;
    --)
	shift
	break
	;;
    *)
	echo "Error: Command line argument \"$1\" unexpected" >&2
	print_syntax >&2
	exit 1
	;;
    esac
done

if [ $# -gt 0 ]; then
    echo "Error: Command line argument \"$1\" unexpected" >&2
    print_syntax >&2
    exit 1
fi

if [ -z "$CERTOPS" ]; then
    echo 'Error: Required command line parameter are missing' >&2
    print_syntax >&2
    exit 1
fi

cert_store_create() {
    if [ ! -d "$cert_store/csrs" ]; then
        mkdir -p $cert_store/csrs
    fi
     if [ ! -d "$cert_store/private" ]; then
        mkdir -p $cert_store/private
    fi

    if [ ! -d "$cert_store/public" ]; then
        mkdir -p $cert_store/public
    fi

}

cert_store_check() {
    if [ -f "$cert_store/csrs/$server_certificate_resource_id.pem" ]; then
        echo "CSR for Server Certificate Resource $server_certificate_resource_id exists already"
        cat "$cert_store/csrs/$server_certificate_resource_id.pem"
        exit 3
    fi

    if [ -f "$cert_store/public/$server_certificate_resource_id.pem" ]; then
        echo "Certificate for Server Certificate Resource $server_certificate_resource_id exists already"
        cat "$cert_store/public/$server_certificate_resource_id.pem"
        exit 3
    fi
}

ca_cert_check() {

    if !  [[ ( -f "$cert_store/private/ca.key" ) &&  ( -f  "$cert_store/public/ca.crt" ) ]]; then

        # CA self certificate
	openssl req -new -nodes -x509 -days 90 -newkey rsa:2048 -keyout "$cert_store/private/ca.key" -out "$cert_store/public/ca.crt" -subj "/C=GB/L=London/CN=$common_name" -addext "subjectAltName=DNS:$common_name" > /dev/null 2>&1
    fi
}

new_csr() {

    cert_store_check >&2

    openssl req -new -newkey rsa:2048 -batch -nodes -keyout "$cert_store/private/$server_certificate_resource_id.pem" -out "$cert_store/csrs/$server_certificate_resource_id.pem" -subj "/C=GB/L=London/CN=$common_name" -addext "subjectAltName=DNS:$common_name" > /dev/null 2>&1
    cat "$cert_store/csrs/$server_certificate_resource_id.pem"
    exit 0

}

new_cert() {

    cert_store_check >&2
    ca_cert_check >&2

    # Generate server cert to be signed
    openssl req -new -newkey rsa:2048 -batch -nodes -keyout "$cert_store/private/$server_certificate_resource_id.pem" -out "$cert_store/csrs/$server_certificate_resource_id.pem" -subj "/C=GB/L=London/CN=$common_name" -addext "subjectAltName=DNS:$common_name" > /dev/null 2>&1

    openssl x509 -req -CA "$cert_store/public/ca.crt" -CAkey "$cert_store/private/ca.key" -CAcreateserial -in "$cert_store/csrs/$server_certificate_resource_id.pem" -out "$cert_store/public/$server_certificate_resource_id.pem" -days 90 > /dev/null 2>&1
  
    cat "$cert_store/public/$server_certificate_resource_id.pem"
    exit 0
}

public_cert_get() {

    if ([ -f "$cert_store/csrs/$server_certificate_resource_id.pem"  ] && ! [ -f "$cert_store/public/$server_certificate_resource_id.pem" ]); then
        echo "Public Certificate for $server_certificate_resource_id not yet available."
        exit 8
    fi

    if [ ! -f "$cert_store/public/$server_certificate_resource_id.pem" ]; then
        echo "Certificate for $server_certificate_resource_id not found"
        exit 4
    fi

    # cat $cert_store/public/$server_certificate_resource_id.pem $cert_store/public/ca.crt

    ts=`stat -c '%Y' /etc/hosts`; TZ=GMT date --date=@$ts +'%a, %d %b %Y %H:%M:%S %Z' > /dev/null 2>&1
    etag=`sha256sum "$cert_store/public/$server_certificate_resource_id.pem"`

    #printf '%s\t%s\t%s\n' \
    #       "$ts" "$etag" `cat "$cert_store/public/$server_certificate_resource_id.pem"`


    echo -e "$ts:$etag:`cat $cert_store/public/$server_certificate_resource_id.pem`"

    exit 0
}

server_cert_get() {

    if ( ! ( [ -f "$cert_store/public/$server_certificate_resource_id.pem"  ] && [ -f "$cert_store/private/$server_certificate_resource_id.pem" ] )); then
        echo "Credentials for $server_certificate_resource_id not yet available."
        exit 8
    fi

    cat $cert_store/public/$server_certificate_resource_id.pem $cert_store/private/$server_certificate_resource_id.pem
    exit 0
}

cert_set() {
<<com
    if ( [ -f "$cert_store/public/$server_certificate_resource_id.pem"  ] || [ -f "$cert_store/csrs/$server_certificate_resource_id.pem" ] ); then
        echo "A certificate or CSR exists already for $server_certificate_resource_id."
        exit 3
    fi

    if ! [ -f "$cert_store/public/$server_certificate_resource_id.pem" ]; then
        echo "$server_certificate_resource_id not found."
        exit 4
    fi

    if ! [ -f "$cert_store/csrs/$server_certificate_resource_id.pem" ]; then
        echo "No CSR issued: $server_certificate_resource_id."
        exit 4
    fi

    if ! [ -f "$cert_store/private/$server_certificate_resource_id.pem" ]; then
        echo "Key $server_certificate_resource_id does not match the private key."
        exit 4
    fi
com

    if ( ! [ -f "$cert_store/public/$server_certificate_resource_id.pem"  ] && [ -f "$cert_store/csrs/$server_certificate_resource_id.pem" ] ); then
        cat > "$cert_store/public/$server_certificate_resource_id.pem"
        exit 0
    
    elif [ -f "$cert_store/public/$server_certificate_resource_id.pem"  ]; then
        echo "Certificate already exists for $server_certificate_resource_id."
        exit 3
    
    elif ! [ -f "$cert_store/csrs/$server_certificate_resource_id.pem"  ]; then
        echo "No CSR issued: $server_certificate_resource_id."
        exit 4
    fi

}

cert_expiry_check() {
    if (openssl x509 -checkend 86400 -noout -in "$cert_store/public/$server_certificate_resource_id.pem" > /dev/null 2>&1) ; then
        cert_status=
    else
        cert_status="Expired or will expire within 24 hours"
    fi
}

cert_list() { 
    if ( [ -f "$cert_store/private/$server_certificate_resource_id.pem"  ] &&  ! [ -f "$cert_store/public/$server_certificate_resource_id.pem" ] ); then
        cert_status="Awaiting"
        cert_subject=
        printf '%s\t%s\n' \
            "$server_certificate_resource_id" "$cert_status"
    elif [ -f "$cert_store/public/$server_certificate_resource_id.pem"  ]; then
        cert_expiry_check >&2
        cert_subject=`openssl x509 -noout -subject -in $cert_store/public/$server_certificate_resource_id.pem`
        printf '%s\t%s\t%s\n' \
            "$server_certificate_resource_id" "$cert_subject" "$cert_status"            
    fi
}


check_cert_revoke() {

    issuer=`openssl x509 -in $cert_store/public/$server_certificate_resource_id.pem -inform PEM -noout -issuer`
    subject=`openssl x509 -in $cert_store/public/$server_certificate_resource_id.pem -inform PEM -noout -subject`
    issuer="${issuer//issuer=/ }"
    subject="${subject//subject=/ }"
    if [ "$issuer" = "$subject" ]; then
        can_be_revoked=0
        echo "Cannot revoke as $server_certificate_resource_id.pem is a self-signed certificate"
    else
        can_be_revoked=1
    fi

}

cert_revoke() {
    check_cert_revoke >&2
    echo "in cert_revoke: $can_be_revoked"
    if [ "$can_be_revoked" -eq "0" ] ; then
	    
    	echo "in cert_revoke:exit 2 $can_be_revoked"
        exit 2
    fi

    openssl ca -revoke $cert_store/public/$server_certificate_resource_id.pem -keyfile "$cert_store/private/ca.key" -cert "$cert_store/public/ca.crt"
    exit 0

}

cert_delete() {
     if ( [ -f "$cert_store/private/$server_certificate_resource_id.pem"  ]); then
            rm -f "$cert_store/private/$server_certificate_resource_id.pem"
     fi
     if ( [ -f "$cert_store/public/$server_certificate_resource_id.pem"  ]); then
            rm -f "$cert_store/public/$server_certificate_resource_id.pem"
     fi
     if ( [ -f "$cert_store/csrs/$server_certificate_resource_id.pem"  ]); then
            rm -f "$cert_store/csrs/$server_certificate_resource_id.pem"
    fi
}

certificate_delete() {

    check_cert_revoke >&2
    if [ "$can_be_revoked" -eq "0" ] ; then
	echo "certificate delete: $can_be_revoked"    
        cert_delete >&2
    else
        cert_revoke >&2
        cert_delete >&2
    fi
    exit 0
}

<<revdel
cert_revoke() {
    check_cert_revoke >&2
    if ! [ $can_be_revoked ]; then
        exit 2
    fi
    exit 0
    
}

cert_delete() {

    cert_revoke >&2
    if ( [ -f "$cert_store/private/$server_certificate_resource_id.pem"  ]); then
        rm -f "$cert_store/private/$server_certificate_resource_id.pem"
    fi


}
revdel


parse_opts() {
    
    read -r -a cert_operation <<< "$CERTOPS"
    if [ "$cert_operation" == "newcsr" ]; then
        if [ ${#cert_operation[@]} -lt 3 ]; then
            echo "$cert_operation: Not enough information to create a new csr"
            exit 1
        fi
        server_certificate_resource_id=${cert_operation[1]}
        common_name=${cert_operation[2]}
        new_csr >&2
        exit 1
    fi

    if [ "$cert_operation" == "newcert" ]; then
        if [ ${#cert_operation[@]} -lt 3 ]; then
            echo "$cert_operation: Not enough information to create a new certificate"
            exit 1
        fi
        server_certificate_resource_id=${cert_operation[1]}
        common_name=${cert_operation[2]}
        new_cert >&2
    fi 

    if [ "$cert_operation" == "publiccert" ]; then
        if [ ${#cert_operation[@]} -eq 2 ]; then
            server_certificate_resource_id=${cert_operation[1]} 
            public_cert_get >&2
        else    
            echo "$cert_operation: has invalid options"
            exit 1
        fi
    fi

    if [ "$cert_operation" == "servercert" ]; then
        if [ ${#cert_operation[@]} -eq 2 ]; then
            server_certificate_resource_id=${cert_operation[1]}
            server_cert_get >&2
        else    
            echo "$cert_operation: has invalid options"
            exit 1
        fi
    fi 

    if [ "$cert_operation" == "setcert" ]; then
        if [ ${#cert_operation[@]} -eq 2 ]; then
            server_certificate_resource_id=${cert_operation[1]}
            cert_set >&2
        else    
            echo "$cert_operation: has invalid options"
            exit 1
        fi
    fi

   if [ "$cert_operation" == "revoke" ]; then
        if [ ${#cert_operation[@]} -eq 2 ]; then
            server_certificate_resource_id=${cert_operation[1]}
            cert_revoke >&2
        else
            echo "$cert_operation: has invalid options"
            exit 1
        fi

    fi

    if [ "$cert_operation" == "delete" ]; then
        if [ ${#cert_operation[@]} -eq 2 ]; then
            server_certificate_resource_id=${cert_operation[1]}
            certificate_delete >&2
        else
            echo "$cert_operation: has invalid options"
            exit 1
        fi

    fi

    if [ "$cert_operation" == "list" ]; then
        if [ ${#cert_operation[@]} -eq 2 ]; then
            server_certificate_resource_id=${cert_operation[1]}
            cert_list >&2
        else
            for pem in $cert_store/public/*.pem; do
                server_certificate_resource_id=`basename "${pem%.*}"`
                cert_list >&2
            done  
        fi
    fi     
}

cert_store_create >&2
parse_opts >&2

exit 0
